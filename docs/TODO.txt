-Add "directory doesn't exist" message to "ls" command.
-Fix: Single \n sign in the line breaks the formatting while using "ls" instruction in the terminal. 
-Create "cursor_pos_x" and "cursor_pos_y" values that return the position of the cursor in the active text field. 
-Ensure scrollbar is always following the text cursor.
-Test zooming and scaling on SuperEditableText.
-Fix: Zooming edited text can move its position.
-Add modules scaling from the edge of the camera.
-Create "save_formatted_text" and "load_formatted_text" instructions to enable saving and loading formatted text (with special data on the start of the file).
-Add previous (for undo) and future (for redo) versions of content to the SuperEditableText. They will be saved on the start of editing and every entered white space just like in vs code. Remember to update support variables. 
-Add previous and future formatting for undo and redo.
-After implementing undo and redo for SuperEditableText, add "original_content" to the "value" instruction (it will be used for editing variables).
-Implement arithmetic instructions and function for vector module (+=, -=, etc.).
-With updated arithmetic instructions improve the auto-complete (remove the loop).
-Moving cursor up or down shouldn't change the "localCursorPos" variable in order to optimize moving around the text.
-Try to remove SuperEditableText's variables from SuperText in order to save on memory. Maybe create copies of some functions like update just for the SuperEditableText.     
-Remove old TextModule and EditableTextModule and rename new modules.
-Remove old, useless functions and methods.

MILESTONE: Terminal and editor with scrolling. - Easy and cozy scripting inside the engine.

-Fix: Extended ASCII characters like "┌" break the text selection (three negative char-s create one wide character).
-Double clicking a word in the text should select this whole word.
-Pressing tab in the editable text module, if more than one letter is selected, should append a tab to the beginning of every selected line. 
-Add to PrimaryModule "vec2b reverseAxes" variable that controls the direction and starting point of the drawing axes on the camera.
-Add to PrimaryModule "vec2b centerAxes" variable that moves the start of the drawing axes to the center of the camera.
-Create the ImageViewer. It would take the image path and check if an image with same path exists. If yes then, it'd connect it to the window object, otherwise it'd load the bitmap to the memory (pseudo caching) and then connect it to the window object.
-Implement optional new line functionality for semicolons in order to divide instructions better.
-Restrict variables' names by not allowing strings that start with numbers and \". Remove the distinction between using context and literals in all instructions. Remove all "zero" variables from scripts.  
-Replace dynamicIDs and Literals in Operations with "struct Argument {VariableModule Value, bool isVariable}" in order to allow mixing Variables and Literals together in the instructions.
-Add to each definition of instructions a function that extracts every value or pointer from the passed Arguments - put them inside the Context vector for example.  
-Replace "start...end" scopes with "func name {...}" "event name (triggers) {...}", "if (conditions) {}", "else if (conditions) {...}", "else {...}" and "while (conditions) {...}" scopes. Names of "if", "else if", "else" and "while" scopes will be generated automatically and start with "_" sign. During compilation, new types of scopes will be seperated from parent events by the parser and put into new events with auto-generated names.
-Add explicit parameters to events and functions (trigger-less events) for better readability. Don't add them to loops, ifs and else, they doesn't need explicit parameters.
-Transform "fun context function [values...]" into "context.function([values...])". Do the same with all other instructions except the arithmetic ones.
-Transform every Reverse Polish Notation into normal expressions.
-Change old move instructions syntax into "left_operand move_instr right_operand;". 
-Change special signs into special signs only inside "print" and in other instances when it is expected.
-Fix: Command "sh print "xd\n"" does not work.
-Fix: Print command doesn't use special signs.
-Update documentation: instructions that use moveOrRename should have a different definition of "output" parameter.
-Add start, end, triggers instructions to the documentation.
-Add to terminal "start" command: should begin bundling the instructions into one string and "end" command should end it and use inject_instr.
-Implement "set_triggers *event* [[trigger] ...]" instruction.
-(?)Implement "set_if *event* *expression*" instruction.
-Move "triggers" to the object definition or bind events to them - right now without using if statements triggers can cause script based bugs. 

MILESTONE: Improve scripting language.

-Block "." and ".." links in filesystem commands.
-Convert all "if forests" to switches.
-Add dmenu, one command line called by a shortcut, that allows to use quick commands like: "open new window", "compile", "run program", etc.
-Add synchronized/shared files that allow for server-like communication between two instances of the engine.
-Implement syntax coloring for the scriptic language.
-Add "unload_bitmaps", "unload_fonts", "unload_bitmap bitmap" and "unload_font font" instructions.
-Add "shell"/"instruction" MODE to the Terminal.
-Use draw_vertical_gradient_rect and draw_horizontal_gradient_rect in a new module that will have a vector of colors.
-Add a glowing "backdoor" that will disable all each_iteration triggers to fight the infinite loops.
-Finish implementing "new_proc" instruction – new processes that overflow the capacity of the vector, will be added to a buffer vector in order to be mutable.
-Upgrade “edit_proc” instruction – process can be found in a normal vector or in a vector buffer of new processes.
-Add deleting processes.
-Add instruction “clone_to_process <context_id> <thread_id> [activate_sim]” – clones layers and cameras from the context from the current thread to a different thread. If activate_sim is true, activate movement, particles and maybe game events. This instruction can be used on layers and cameras that have first been cloned locally in order to activate/deactivate specific entities and scripts.
-Add instruction “move_to_process <context_id> <thread_id> [activate_sim]” – moves (clone and delete) layers and cameras from the context from the current thread to a different thread. If activate_sim is true, activate movement, particles and maybe game events. This instruction can be used on layers and cameras that have first been cloned locally in order to activate/deactivate specific entities and scripts.
-Think about better way of getting attributes from module contexts.
-Evolve "random_int" instruction into universal "random".
-Add more milestones.
-Remember: inside the map editor, instead of making a lot of "solid" objects, you just need a single object with many images and collisions.
-Copy tilemap editor from Godot.
-Connect primitives to cameras.
-Add selection rectangle to the mouse for multiple object selection.
-Change object selection borders to primitives?
-Add an interactive grid for object snapping in the gui designer and tile based games.
-Implement tilling manager for windows.
-Add window: Terminal.
-Add window: Ranger based filesystem. 
-Add window: Options - shows the list of options/functions of the entity/window, every list item is a button, camera is immobilized, minimizes when mouse is out of focus.
-Add window: Filesystem – displays container for entities (threads, projects, layers, cameras, objects, modules, images, text, etc.). You cannot move camera freely. You can scroll up and down. Right clicking on the entity brings up the Options window. Filesystem has many display mods: list, icons, movable icons (like in old macs, very easy to implement because icons are just objects), tree (like in vs code). You can also open different threads like different partitions, but that might be problematic.
-Add window: ImagePlacement - only draws images of a one object, you can move images around, you can also move camera. On technical plane, objects in this window directly correspond/point to images from the chosen object.
-Add window: CollisionPlacement – gives access to collision borders of a one object, you can move them around, you can also move camera. Aside from borders, window also draws chosen object images. On technical plane, objects in this window directly correspond/point to collision borders and images from the chosen object, but you can only interact with collisions.
-Add window: EditEntity - custom for every other entity, lists all editable parameters (EditableTexts) and eventual sliders, has up-down scrollbar, camera is immobilized.
-Add window: Wim - text editor, has four directional scrollbar, camera is... idk.
-Add window: Logs – the list of text fields, up-down scrollbar. Lists logs from its process.
-Add window: DisplayCameras – shows a vertical list of cameras in the order of display. Does not include this window. User can filter out cameras based on access level and groups. User can move cameras around, switching their order of display. Window’s camera is immobilized. There is up-down scrollbar.
-Add window: GameRunner/VirtualMachine/Simulator/Streamer/SSH - takes layers and cameras from a different process and allows user to interact with it in the current process. Its main goal is to run/test a game/program independently from the current development session. For example if you are in the process of creating a game, you press run button and this window is created. You can now play this game safely, make progress, have fun, test some new feature. If finish playing, just close the window and you will see that nothing changed in the game editor, because the game you played was just a clone of your game.
-Add window: DuctTape – Paint. Why Tape? Because Paint keeps the world in one piece like tape.
-Implement access to windows based on “access to engine windows.PNG” or find it in Miro.

-You should be able to save any type of entity from the engine by using "save <context> <fileName> [force]" instruction. Saving entity or a vector of entities (context) first writes a type and number of entities to the file and then all entities' data. If the file already exists and have any content inside, instruction will fail. By using force, engine will overwrite the previous content of the chosen file.
-Add "load <fileName> <context> [force]" instruction. Load will overwrite all entities in the context based on the contents of the file. If the user doesn't provide big enough context, instruction will fail. By using force, engine will create new (valid number of) entities, add them to the context and finally overwrite everything.
-Add "version" variable to each entity. This version will be saved to the file with each entity. Later, if any changes are made to any entity, you will be able to create a converter, which will convert any old entity to its newest version. This is crucial for the backwards compatibility.
-Projects will be an another type of entity and it will ensure standardized way of saving and loading entities.
-Add hyperlinks to the SuperText. Clicking them will trigger an event.
-Create LayerManagerWindow / Project tree.
-Add logging system with filters and colors.
-Implement variable change detection and add it to triggers lookup table.
-Add “areObjectsActive” bool to layers – if it’s true, modules and events of objects in this layer can be executed. Reason: layers are processes and can become games by cloning them and switching “areObjectsActive” to true.
-Add “IDPermissions”, “groupPermissions” vectors to layers.
-Events can access context of layers in layer’s IDPermissions and groupPermissions.
-Add mouse selection to if statement sources.
-Update realAreaOfScrolling.
-Editables should update its value in the beginning and on update of the connected variable now it's just hard-wired in editor.
-Undo, redo.

-MILESTONE: you can configure every object visible on the map using OBJECT EDITOR (look up program_model.png)

-Pick up an object from TREE OF OBJECTS instead of only from the map to change edit window context; TREE OF OBJECTS is a file tree.
-Save and load projects.

-MILESTONE: you can save current project (with all objects and configurations), load saved projects, create a new project.

-Implement search bar for TREE OF OBJECTS.
-Remove light bitmap and implement hsva color management instead of rgba.
-Update drawing frames.
-Add platforms that you can hop on from any directions.
-Add Animation Module - animation creator (choosing sub-images from chosen image module, duration of each frame). Animation Module contains animation time, speed of animation, animation choreographics and currently used choreography (character is moving upwards, downwards, etc.).
-Add sound module.
-Add image library: use getAllFilesNamesWithinFolder() with scaled images.
-Movement update: chain move (vector based move).
-Add horizontal dash move to movement.
-Add friction from objects that are under moving objects.
-Add bouncing from walls (balls in themselves or objects from other objects).
-Add physics.
-Add vehicle like movement (use movement of particles)
-Add particles that imitate a campfire, fire and smoke (use a noise map)
-Add diagonal walking (going up or descending a ramp) and sliding off the ramp. Movement function asks for ground degree (rotation of an object) and rotates speed vector according to this degree (fast descending, slow ascending, because vertical speed translates to horizontal speed).
-To collision module add lines of hitmap, add to collisions cords of the center (center of rotating), add rotating objects (create vectors that come from center of the object to every point of hitmap, rotate these vectors and move previous points to new locations - use wektorki main)
-Add collisions with lines using intersection project.
-Allow moving objects to move other objects using vectors (rotating objects will have momentum vectors used only to move other objects).
-Add blur: takes color from few pixels and create brighter and darker squares with a little bit of alpha around the object; takes pixels from whole objects and uses avarage to blur an image; takes color from the closest sides of objects and fills the space between these two sides using avarage colors (ropes).
-Add object goes many objects (cutting images using lines and dividing object into few small objects)
-Add shape controler module: mainly used as hitboxes, can be used in vector graphics. There are two modes: draw by squares or draw normally. By pressing Q and LMB you create a point and the line from this point focuses on your mouse pointer. By clicking LMB again you create a new point with a line connecting both points. You can connect two existing points, but if there was a line, you don't create a new one. If you click RMB, the drawing is over, but if you click LMB on existing point, you can draw again from that point (or Q+LMB). By pressing shift you can draw horizontally, vertically and diagonally. If option „fill with color” is enable, the program fills with chosen color or colors only triangles
-Make transition/special effects module (old pixelated transition, star wars transition (moving wall changes one scene to another), blur, everything turns white or black, random pixels/lines missing, old television errors, convex screen)
-Inverse cinematics
-Fabric algorithm
-Depth maps
-Add filling imageModule full area with used image if isFilledWithCopies is true
-Play ascii Bad Apple.
-Add gifs.
-Make donut.cpp with EGM script.
-Make version control system (local github).
-Add the possiblity to convert particle frames into images for the optimalization.
-Add 3D graphics - this will include adding 3D rendering inside the code editor for showing the models used by the scripts.

OPTIMALIZATIONS
-Use std::variant instead of unions.
-Create special versions of engine instructions with a lower count of ifs - these instructions will be unsafe and could cause crashes, but when used in a right way (with other trusted instructions) they could speed up the engine. The script compiler will dynamically choose best versions of the instructions. Example: if one instruction WILL provide a non-null pointer, the second instruction should be able to ignore checking if this pointer is empty. 
-Use constexpr - this will pre-calculate some functions in compile time, speeding up some of them to O(1).
-For large scale simulation: Divide game map to different threads based on camera position. The main thread will have rights to draw things and others will be focusing on processing stuff.
-Function createNewModule recalculates indexes of all modules for each module added. Remove template and create custom index recalculation for each module.
-Bounding volume hierarchy (or marching squares) – group objects into the biggest “boxes/chunks” possible and iterate only through chunks where is the player (could work only for collisions). 
-Declare variables as locally as possible.
-Replace every vec2d with vec2f.
-Replace big if else statements with switch and enum.
-Use ++iterator – it’s faster. 
-Use “const &” on every OBJECT (not variables).
-Try unorganised_list for password-function connection in EditableText module.
-Divide drawing on cameras to threads.
-Instead of running for loops everywhere, make hash map from IDs or something.
-(Memory optimalization) Single Particles have only positions and Module has few vectors of randomized variables and single particles use them.
-(Performance optimalization) Add a vector that tells which objects have particles.
-Add threads: one for moving and one for drawing particles.

BUGS
-Keyboard input can be randomly and permamently doubled. Clue:
"...just make sure you handle the ALLEGRO_EVENT_DISPLAY_LOST and ALLEGRO_EVENT_DISPLAY_FOUND events, and redraw when you get the latter event." 
-Vector movement doesn’t support camera movement
-60 FPS max
-Random copies of letters in editable fields - when you release few buttons at once editable text does undefined behavior. Do: when one button is pressed, every [var] seconds letter is entered, but when another button is pressed, the previous ones are 100% blocked until release (like in notepad)
-Pointers in contexts may point to deleted entities (deleted = true).
