If context exists, then delete it and put the new context in its place with the same id. Otherwise rename the new context.
let x context -> delete x; rename context (with) x
all/first/last/random ... x -> let x
index ... x -> let x
find_by_id ... x -> let x
new ... x -> let x
sum left right x -> let x
intersection left right x -> let x
difference left right x -> let x
var ... x -> let x

If compatible, then move. Otherwise ERROR.
=,+=,-=,*=,/= left right -> = left right

If context exists and has compatible type, then move. If context exists but has wrong type, then ERROR. Otherwise rename the new context.
value expression x -> = x [result] || rename [back] x
bool/int/double/string [values] x -> = x [values] || rename [back] x
random_int ... x -> = x [values] || rename [back] x
+,-,*,/ left right x -> = x [result] || rename [back] x
in left right x -> = x [result] || rename [back] x
print ... x ... -> = x [result:string] || rename [back] x
= x [result] || rename [back] x -> move_or_rename


Others:
clone left right -> clone left right
++,-- context -> ++,-- context
power_off
reboot
return
break
delete_this_event
continue
delete x
bind x ...
build x reset
build_subset ...
load_build ...
inject_code ...
inject_instr ...
demolish x ...
env ...
edit_proc ...
fun x ...
load_bitmap ...
mkdir path
rm path
rmll path
load_text ...
save_text ...
ls ...

56