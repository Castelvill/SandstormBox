subjects: layer, obj, camera, mouse
abstract subjects: each_second, let, me, if, else, first, last, forall, break, return
-each_second - executes code inside of brackets every second

functions:
-[variable_name].execute(string script_id) - executes a script with this id
-[variable_name].kill() - erases this object
-[variable_name].inGroup(string group) - returns true if the object is in the group
-[variable_name].clone(int amount) - creates amount of copies of the object
-[variable_name].transform_into([variable_name]) - transforms an object into a choosen object
-layer(string id) - returns a handle to the layer with id
-layer(string id, string script_id) - returns a handle to the layer with id and activates a script with script_id
-bool [variable_name].collision_with([variable_name]) - returns true if collision was detected

[variable_name] <= layer.[layer_id].[obj_id].[module].[elem_id].[attr]
obj <= layer.current
[variable_name] <= obj.[obj_id].[module].[elem_id].[attr]

//Maybe all value based variables should be saved to me.var? 
[variable_name] <==> me.var.[variable_name]

Root of the script:
    let [variable_name] = [variable_name];
    let [variable_name] = [string];
    let [variable_name] = [number];
    [quantifier](logical_expression){executed_code}
    [always]{executed_code}

Logical expression:
    [operator]
    [number]
    [string]
    [variable_name] - getters

Executed code:
    let [variable_name] = [variable_name];
    let [variable_name] = [string];
    let [variable_name] = [number];
    [variable_name].[method](<parameters>);
    [quantifier](logical_expression){executed_code}
    break
