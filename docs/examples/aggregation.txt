1) Single aggregation
vec x = all(group=="enemy");
x.var.money++;

2) Two aggregations
vec x = all(group=="bob");
x.var.gold++;
x = all(var.gold < 5);
x.var.gold += 500;

3) Referencing two variables
vec x = all(group=="bob");
x.var.gold++;
vec y = all(x.var.gold < 5);
y.var.gold += 500;
x.var.debt += 10;

4)Complex aggregation
group a = all(group == "a"); //a=50
vec d = all(group == "d"); //d=10
vec ad = all(a.group == "d"); //ad=10
vec ad2 = all(group == "a" && group == "d"); //ad2=ad=10
vec ad3 = all(group == "a" || group == "d"); //ad3=a+d=60
vec ad4 = a||d; //ad4=ad3=60
vec ad5 = a&&d; //ad5=ad2=10

5) Passing aggregated context to conditional events
vec a = all(group=="a");
vec b = all(group=="b");
vec c = all(group=="c");
if(me.var.a == true){ //pass whole a
	a.var.money++;
	//for obj in a: obj.var.money++;
}
if(me.var.b == true && me.var.c == true){ //pass whole b and c
	b.var.money++;
	//for obj in b: obj.var.money++;
	c.var.money++;
	//for obj in c: obj.var.money++;	
}

6)Atomic operations without conditions - cartesian product
//c++esk
for a in groupA{
	a.var.random = rand(0, 50);
	for b in groupB{
		b.var.value = a.var.random;
		b.events.GiveRandomThing();
	}
}
//Goo
vec a = all(group == "groupA"); //a=10
vec b = all(group == "groupB"); //b=20
atomic(a){ //pass 1 a and whole b at the time
	a.var.random = rand(0, 50); //a=1
	b.var.value = a.var.random; //b=20
	b.events.GiveRandomThing(); //b=20
}
atomic(a, b){ //pass 1 a and 1 b at the time
	a.var.random = rand(0, 50); //a=1
	b.var.value = a.var.random; //b=1
	b.events.GiveRandomThing(); //b=1
}

7) Atomic operations with conditions - cartesian product
//c++
for (a in guy){
	for (b in enemy){
		if a.var.money > 0{
			let haracz=rand(0, a.money);
			b.var.money+=haracz;
			a.var.money-=haracz;
		}else{
			a.var.hp-=1;
		}
	}
}
//Goo
vec enemy = all(group=="enemy"); //enemy=10
vec guy = all(group=="guy"); //guy=20
atomic(guy, enemy){ //pass 1 guy and 1 enemy at a time
	if(guy.var.money > 0){ //pass 1 guy and 1 enemy at a time
		int Haracz = rand(0, guy.var.money);
		enemy.var.money += Haracz; //enemy=1, if atomic was not specified, every Haracz would be duplicated to every enemy for each guy
		guy.var.money -= Haracz; //guy=1
	}
	else{  //pass 1 guy and 1 enemy at a time
		guy.var.hp -= 1; //guy=1
	}
}


8)Pair - based on existing order
vec enemy = all(group=="enemy"); //enemy=10
vec guy = all(group=="guy"); //guy=20
pair(guy, enemy){ //pass unique pairs of 1 guy and 1 enemy at a time
	if(guy.var.money > 0){ //pass 1 guy and 1 enemy at a time
		int Haracz = rand(0, guy.var.money);
		enemy.var.money += Haracz; //enemy=1
		guy.var.money -= Haracz; //guy=1
	}
	else{  //pass 1 guy and 1 enemy at a time
		guy.var.hp -= 1; //guy=1
	}
}

9)Random Pair - based on random order
vec enemy = all(group=="enemy"); //enemy=10
vec guy = all(group=="guy"); //guy=20
rand_pair(guy, enemy){ //pass random unique pairs of 1 guy and 1 enemy at a time
	if(guy.var.money > 0){ //pass 1 guy and 1 enemy at a time
		int Haracz = rand(0, guy.var.money);
		enemy.var.money += Haracz; //enemy=1
		guy.var.money -= Haracz; //guy=1
	}
	else{  //pass 1 guy and 1 enemy at a time
		guy.var.hp -= 1; //guy=1
	}
}